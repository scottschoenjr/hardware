function [methodinfo,structs,enuminfo,ThunkLibName]=usbtc08MFile
%USBTC08MFILE Create structures to define interfaces found in 'usbtc08'.

%This function was generated by loadlibrary.m parser version  on Mon Dec  5 15:52:23 2016
%perl options:'usbtc08.i -outfile=usbtc08MFile.m -thunkfile=usbtc08_thunk_pcwin64.c -header=usbtc08.h'
ival={cell(1,0)}; % change 0 to the actual number of functions to preallocate the data.
structs=[];enuminfo=[];fcnNum=1;
fcns=struct('name',ival,'calltype',ival,'LHS',ival,'RHS',ival,'alias',ival,'thunkname', ival);
MfilePath=fileparts(mfilename('fullpath'));
ThunkLibName=fullfile(MfilePath,'usbtc08_thunk_pcwin64');
% int16_t  __stdcall usb_tc08_set_channel ( int16_t handle , int16_t channel , char tc_type ); 
fcns.thunkname{fcnNum}='int16int16int16int8Thunk';fcns.name{fcnNum}='usb_tc08_set_channel'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int16'; fcns.RHS{fcnNum}={'int16', 'int16', 'int8'};fcnNum=fcnNum+1;
% int32_t  __stdcall usb_tc08_run ( int16_t handle , int32_t interval_ms ); 
fcns.thunkname{fcnNum}='int32int16int32Thunk';fcns.name{fcnNum}='usb_tc08_run'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'int16', 'int32'};fcnNum=fcnNum+1;
% int32_t  __stdcall usb_tc08_get_temp ( int16_t handle , float * temp_buffer , int32_t * times_ms_buffer , int32_t buffer_length , int16_t * overflow , int16_t channel , int16_t units , int16_t fill_missing ); 
fcns.thunkname{fcnNum}='int32int16voidPtrvoidPtrint32voidPtrint16int16int16Thunk';fcns.name{fcnNum}='usb_tc08_get_temp'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'int16', 'singlePtr', 'int32Ptr', 'int32', 'int16Ptr', 'int16', 'int16', 'int16'};fcnNum=fcnNum+1;
% int32_t  __stdcall usb_tc08_get_temp_deskew ( int16_t handle , float * temp_buffer , int32_t * times_ms_buffer , int32_t buffer_length , int16_t * overflow , int16_t channel , int16_t units , int16_t fill_missing ); 
fcns.thunkname{fcnNum}='int32int16voidPtrvoidPtrint32voidPtrint16int16int16Thunk';fcns.name{fcnNum}='usb_tc08_get_temp_deskew'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'int16', 'singlePtr', 'int32Ptr', 'int32', 'int16Ptr', 'int16', 'int16', 'int16'};fcnNum=fcnNum+1;
% int16_t  __stdcall usb_tc08_get_single ( int16_t handle , float * temp , int16_t * overflow_flags , int16_t units ); 
fcns.thunkname{fcnNum}='int16int16voidPtrvoidPtrint16Thunk';fcns.name{fcnNum}='usb_tc08_get_single'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int16'; fcns.RHS{fcnNum}={'int16', 'singlePtr', 'int16Ptr', 'int16'};fcnNum=fcnNum+1;
% int16_t  __stdcall usb_tc08_open_unit ( void ); 
fcns.thunkname{fcnNum}='int16voidThunk';fcns.name{fcnNum}='usb_tc08_open_unit'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int16'; fcns.RHS{fcnNum}=[];fcnNum=fcnNum+1;
% int16_t  __stdcall usb_tc08_open_unit_async ( void ); 
fcns.thunkname{fcnNum}='int16voidThunk';fcns.name{fcnNum}='usb_tc08_open_unit_async'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int16'; fcns.RHS{fcnNum}=[];fcnNum=fcnNum+1;
% int16_t  __stdcall usb_tc08_open_unit_progress ( int16_t * handle , int16_t * percent_progress ); 
fcns.thunkname{fcnNum}='int16voidPtrvoidPtrThunk';fcns.name{fcnNum}='usb_tc08_open_unit_progress'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int16'; fcns.RHS{fcnNum}={'int16Ptr', 'int16Ptr'};fcnNum=fcnNum+1;
% int16_t  __stdcall usb_tc08_close_unit ( int16_t handle ); 
fcns.thunkname{fcnNum}='int16int16Thunk';fcns.name{fcnNum}='usb_tc08_close_unit'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int16'; fcns.RHS{fcnNum}={'int16'};fcnNum=fcnNum+1;
% int16_t  __stdcall usb_tc08_stop ( int16_t handle ); 
fcns.thunkname{fcnNum}='int16int16Thunk';fcns.name{fcnNum}='usb_tc08_stop'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int16'; fcns.RHS{fcnNum}={'int16'};fcnNum=fcnNum+1;
% int16_t  __stdcall usb_tc08_set_mains ( int16_t handle , int16_t sixty_hertz ); 
fcns.thunkname{fcnNum}='int16int16int16Thunk';fcns.name{fcnNum}='usb_tc08_set_mains'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int16'; fcns.RHS{fcnNum}={'int16', 'int16'};fcnNum=fcnNum+1;
% int32_t  __stdcall usb_tc08_get_minimum_interval_ms ( int16_t handle ); 
fcns.thunkname{fcnNum}='int32int16Thunk';fcns.name{fcnNum}='usb_tc08_get_minimum_interval_ms'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'int16'};fcnNum=fcnNum+1;
% int16_t  __stdcall usb_tc08_get_unit_info ( int16_t handle , USBTC08_INFO * info ); 
fcns.thunkname{fcnNum}='int16int16voidPtrThunk';fcns.name{fcnNum}='usb_tc08_get_unit_info'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int16'; fcns.RHS{fcnNum}={'int16', 'tUSBTC08InfoPtr'};fcnNum=fcnNum+1;
% int16_t  __stdcall usb_tc08_get_unit_info2 ( int16_t handle , char * string , int16_t string_length , int16_t line ); 
fcns.thunkname{fcnNum}='int16int16cstringint16int16Thunk';fcns.name{fcnNum}='usb_tc08_get_unit_info2'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int16'; fcns.RHS{fcnNum}={'int16', 'cstring', 'int16', 'int16'};fcnNum=fcnNum+1;
% int16_t  __stdcall usb_tc08_get_formatted_info ( int16_t handle , char * unit_info , int16_t string_length ); 
fcns.thunkname{fcnNum}='int16int16cstringint16Thunk';fcns.name{fcnNum}='usb_tc08_get_formatted_info'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int16'; fcns.RHS{fcnNum}={'int16', 'cstring', 'int16'};fcnNum=fcnNum+1;
% int16_t  __stdcall usb_tc08_get_last_error ( int16_t handle ); 
fcns.thunkname{fcnNum}='int16int16Thunk';fcns.name{fcnNum}='usb_tc08_get_last_error'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int16'; fcns.RHS{fcnNum}={'int16'};fcnNum=fcnNum+1;
% int16_t  __stdcall usb_tc08_legacy_run ( int16_t handle ); 
fcns.thunkname{fcnNum}='int16int16Thunk';fcns.name{fcnNum}='usb_tc08_legacy_run'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int16'; fcns.RHS{fcnNum}={'int16'};fcnNum=fcnNum+1;
% int16_t  __stdcall usb_tc08_legacy_set_channel ( int16_t handle , int16_t channel , char tc_type , int16_t filter_factor , int16_t offset , int16_t slope ); 
fcns.thunkname{fcnNum}='int16int16int16int8int16int16int16Thunk';fcns.name{fcnNum}='usb_tc08_legacy_set_channel'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int16'; fcns.RHS{fcnNum}={'int16', 'int16', 'int8', 'int16', 'int16', 'int16'};fcnNum=fcnNum+1;
% int16_t  __stdcall usb_tc08_legacy_get_temp ( int32_t * temp , int16_t handle , uint16_t channel , uint16_t filtered ); 
fcns.thunkname{fcnNum}='int16voidPtrint16uint16uint16Thunk';fcns.name{fcnNum}='usb_tc08_legacy_get_temp'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int16'; fcns.RHS{fcnNum}={'int32Ptr', 'int16', 'uint16', 'uint16'};fcnNum=fcnNum+1;
% int16_t  __stdcall usb_tc08_legacy_get_cold_junction ( int32_t * temp , int16_t handle ); 
fcns.thunkname{fcnNum}='int16voidPtrint16Thunk';fcns.name{fcnNum}='usb_tc08_legacy_get_cold_junction'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int16'; fcns.RHS{fcnNum}={'int32Ptr', 'int16'};fcnNum=fcnNum+1;
% int16_t  __stdcall usb_tc08_legacy_get_driver_version ( void ); 
fcns.thunkname{fcnNum}='int16voidThunk';fcns.name{fcnNum}='usb_tc08_legacy_get_driver_version'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int16'; fcns.RHS{fcnNum}=[];fcnNum=fcnNum+1;
% int16_t  __stdcall usb_tc08_legacy_get_version ( int16_t * version , int16_t handle ); 
fcns.thunkname{fcnNum}='int16voidPtrint16Thunk';fcns.name{fcnNum}='usb_tc08_legacy_get_version'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int16'; fcns.RHS{fcnNum}={'int16Ptr', 'int16'};fcnNum=fcnNum+1;
% int16_t  __stdcall usb_tc08_legacy_get_cycle ( int32_t * cycle , int16_t handle ); 
fcns.thunkname{fcnNum}='int16voidPtrint16Thunk';fcns.name{fcnNum}='usb_tc08_legacy_get_cycle'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int16'; fcns.RHS{fcnNum}={'int32Ptr', 'int16'};fcnNum=fcnNum+1;
structs.tUSBTC08Info.members=struct('size', 'int16', 'DriverVersion', 'int8#12', 'PicoppVersion', 'int16', 'HardwareVersion', 'int16', 'Variant', 'int16', 'szSerial', 'int8#11', 'szCalDate', 'int8#9');
enuminfo.enUSBTC08Progress=struct('USBTC08_PROGRESS_FAIL',-1,'USBTC08_PROGRESS_PENDING',0,'USBTC08_PROGRESS_COMPLETE',1);
enuminfo.enUSBTC08Units=struct('USBTC08_UNITS_CENTIGRADE',0,'USBTC08_UNITS_FAHRENHEIT',1,'USBTC08_UNITS_KELVIN',2,'USBTC08_UNITS_RANKINE',3,'USBTC08_MAX_UNITS',3);
enuminfo.enUSBTC08Error=struct('USBTC08_ERROR_OK',0,'USBTC08_ERROR_OS_NOT_SUPPORTED',1,'USBTC08_ERROR_NO_CHANNELS_SET',2,'USBTC08_ERROR_INVALID_PARAMETER',3,'USBTC08_ERROR_VARIANT_NOT_SUPPORTED',4,'USBTC08_ERROR_INCORRECT_MODE',5,'USBTC08_ERROR_ENUMERATION_INCOMPLETE',6,'USBTC08_ERROR_NOT_RESPONDING',7,'USBTC08_ERROR_FW_FAIL',8,'USBTC08_ERROR_CONFIG_FAIL',9,'USBTC08_ERROR_NOT_FOUND',10,'USBTC08_ERROR_THREAD_FAIL',11,'USBTC08_ERROR_PIPE_INFO_FAIL',12,'USBTC08_ERROR_NOT_CALIBRATED',13,'USBTC08_EROOR_PICOPP_TOO_OLD',14,'USBTC08_ERROR_PICOPP_TOO_OLD',14,'USBTC08_ERROR_COMMUNICATION',15);
enuminfo.enUSBTC08InfoLine=struct('USBTC08LINE_DRIVER_VERSION',0,'USBTC08LINE_KERNEL_DRIVER_VERSION',1,'USBTC08LINE_HARDWARE_VERSION',2,'USBTC08LINE_VARIANT_INFO',3,'USBTC08LINE_BATCH_AND_SERIAL',4,'USBTC08LINE_CAL_DATE',5);
enuminfo.enUSBTC08Channels=struct('USBTC08_CHANNEL_CJC',0,'USBTC08_CHANNEL_1',1,'USBTC08_CHANNEL_2',2,'USBTC08_CHANNEL_3',3,'USBTC08_CHANNEL_4',4,'USBTC08_CHANNEL_5',5,'USBTC08_CHANNEL_6',6,'USBTC08_CHANNEL_7',7,'USBTC08_CHANNEL_8',8,'USBTC08_MAX_CHANNELS',8);
methodinfo=fcns;